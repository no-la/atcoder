{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	"main": {
		"prefix": "main",
		"body": [
			"if __name__ == '__main__':",
			"    ${1:pass}"
		],
		"description": "main"
	},
	"direction": {
		"prefix": "direction",
		"body": [
			"s = ${1:str}",
            "if s==\"L\":",
            "    delta = (0, -1)",
            "elif s==\"R\":",
            "    delta = (0, 1)",
            "elif s==\"U\":",
            "    delta = (-1, 0)",
            "elif s==\"D\":",
            "    delta = (1, 0)"
		]
	},
	"lrud": {
		"prefix": "lrud",
		"body": "[[0, -1],[0, 1],[-1, 0],[1, 0]]"
	},
	"abcdefg": {
		"prefix": "abcdefg",
		"body": [
			"\"abcdefghijklmnopqrstuvwxyz\""
		]
	},
	"ABCDEFG": {
		"prefix": "ABCDEFG",
		"body": [
			"\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\""
		]
	},
	"N": {
		"prefix": "N",
		"body": [
			"N = int(input())"
		]
	},
	"NM": {
		"prefix": "NM",
		"body": [
			"N, M = map(int, input().split())"
		]
	},
	"HW": {
		"prefix": "HW",
		"body": [
			"H, W = map(int, input().split())"
		]
	},
	"inti": {
		"prefix": "inti",
		"body": [
			"int(input())"
		]
	},
	"mapi": {
		"prefix": "mapi",
		"body": [
			"map(${1:int}, ${2:input().split()})"
		]
	},
	"for_": {
		"prefix": "for_",
		"body": [
			"for _ in range(${1:N}):"
		]
	},
	"fori": {
		"prefix": "fori",
		"body": [
			"for i in range(${1:N}):"
		]
	},
	"forj": {
		"prefix": "forj",
		"body": [
			"for j in range(${1:N}):"
		]
	},
	"sep": {
		"prefix": "sep",
		"body": "sep=\"\\n\""
	},
	"defaultdict": {
		"prefix": "defaultdict",
		"body": [
			"from collections import defaultdict",
			"d = defaultdict(${1:list})"
		]
	},
	"bisect": {
		"prefix": "bisect",
		"body": [
			"import bisect",
			"# 基本的にbisect_leftを使う",
			"# 渡す配列は昇順(reverse=False)ソートしておく"
		]
	},
	"heapq": {
		"prefix": "heapq",
		"body": [
			"from heapq import heapify, heappop, heappush",
			"#heapify(a:list)",
			"#heappop(a) (最小値)",
			"#heappush(a, value)"
		]
	},
	"permutation": {
		"prefix": "permutation",
		"body": [
			"# 順列 O(nPk)<=n!",
			"import itertools",
			"for l in itertools.permutations(${1:要素のリスト}, ${2:選ぶ個数}):"
		]
	},
	"combination": {
		"prefix": "combination",
		"body": [
			"# 重複なし組み合わせ O(nCk)",
			"import itertools",
			"for l in itertools.combinations(${1:要素のリスト}, ${2:選ぶ個数}):"
		]
	},
	"homogeneous": {
		"prefix": "homogeneous",
		"body": [
			"# 重複あり組み合わせ O(nHk)=O(n+k-1Ck)",
			"import itertools",
			"for l in itertools.combinations_with_replacement(${1:要素のリスト}, ${2:選ぶ個数}):"
		]
	},
	"syakutori": {
		"prefix": "syakutori",
		"body": [
			"# 尺取り法",
			"ans = 0",
			"right = 0",
			"temp = ${1:初期値} #部分列による値（条件の判定に必要なときに使う）",
			"for left in range(${2:N}):",
			"\twhile ${3:部分列が満たすべき条件}: # 条件の判定",
			"\t\ttemp += ${4:A[right]}",
			"\t\tright += 1",
			"\tans = ${5:max}(ans, right-left)",
			"\tif left == right: # [left, right)が空集合なので'temp=初期値'になっているはず",
			"\t\tright += 1",
			"\telse: #このあとleftを+1するので、その分の情報を削る",
			"\t\ttemp -= ${6:A[left]}"
		]
	},
	"BFS": {
		"prefix": "BFS",
		"body": [
			"# BFS",
			"from collections import deque",
			"todo = deque(${1:初期値})",
			"dist = [-1]*${2:N} #todo[0]からの距離のリスト",
			"dist[${3:todo[0]}] = 0",
			"while todo:",
			"\tv = todo.popleft()",
			"\tfor ${4:w in vの周り}:",
			"\t\tif dist[${5:w}]!=-1: # 既に調べた点は飛ばす",
			"\t\t\tcontinue",
			"\t\tif ${6:調べる点が満たすべき条件}:",
			"\t\t\ttodo.append(${7:点})",
			"\t\t\tdist[${8:w}] = dist[${9:v}]+1"
		]
	},
	"DFS": {
		"prefix": "DFS",
		"body": [
			"# DFS",
			"from collections import deque",
			"todo = deque(${1:初期値})",
			"seen = [False]*${2:N} # ここはsetでもよい",
			"seen[${3:todo[0]}] = True",
			"while todo:",
			"\tv = todo.pop()",
			"\tfor ${4:w in vの周り}:",
			"\t\tif seen[${5:w}]: # 既に調べた点は飛ばす",
			"\t\t\tcontinue",
			"\t\tif ${6:調べる点が満たすべき条件}:",
			"\t\t\ttodo.append(${7:点})",
			"\t\t\tseen[${8:w}] = True"
		]
	},
	"imos": {
		"prefix": "imos",
		"body": [
			"# imos法",
			"imos = [0]*${1:N}",
			"#始点に+x, 終点の次の点に-xする",
			"# 適当な処理",
			"for i in range(1, len(imos)):",
			"\timos[i] += imos[i-1]"
		]
	},
	"segmentTree": {
		"prefix": "segmentTree",
		"body": [
			"class SegTree:",
			"\tdef __init__(self, num, e, operator=max):",
			"\t\t\"\"\"",
			"\t\tparameter",
			"\t\t\tnum : 要素数",
			"\t\t\te : 単位元(初期値)",
			"\t\t\toperator : 2つの子ノードの値から親ノードの値を作る関数",
			"\t\t\"\"\"",
			"\t\t#self.tree[i+self.offset]:要素iのみの区間の値",
			"\t\tself.offset = 1 << (num-1).bit_length()",
			"\t\tself.tree = [e]*(self.offset<<1)",
			"\t\tself.e = e",
			"\t\tself.operator = operator",
			"\t",
			"\tdef update(self, i, value):",
			"\t\t\"\"\"i番目の要素をvalueにする",
			"\t\t\"\"\"",
			"\t\ti += self.offset",
			"\t\tself.tree[i] = value",
			"\t\t#親ノードを順に変更していく",
			"\t\twhile i>1:",
			"\t\t\tv1, v2 = self.tree[i], self.tree[i^1] #子ノード",
			"\t\t\ti >>= 1 #iを親ノードへずらす",
			"\t\t\tself.tree[i] = self.operator(v1, v2)",
			"\t\t\t",
			"\tdef get_point(self, p):",
			"\t\t\"\"\"p番目の要素を取得する",
			"\t\t\"\"\"",
			"\t\treturn self.tree[p+self.offset]",
			"\t",
			"\tdef get_range(self, l, r):",
			"\t\t\"\"\"区間[l, r)の値を取得する",
			"\t\t\"\"\"",
			"\t\tl += self.offset",
			"\t\tr += self.offset",
			"\t\t",
			"\t\tans = self.e",
			"\t\twhile l<r:",
			"\t\t\tif r&1:",
			"\t\t\t\tans = self.operator(ans, self.tree[r-1])",
			"\t\t\t\tr -= 1",
			"\t\t\tif l&1:",
			"\t\t\t\tans = self.operator(ans, self.tree[l])",
			"\t\t\t\tl += 1",
			"\t\t\tl >>= 1",
			"\t\t\tr >>= 1",
			"\t\treturn ans"
				]
	},
	"dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"import heapq",
			"",
			"def dijkstra(edges, N, start=0):",
			"\t\"\"\"",
			"\tparameter",
			"\t\tedges[i][_] : [点iから向かう点, コスト]",
			"\t\tN : 点の個数(=len(edges))",
			"\t\tstart : 探索を始める点",
			"\t\"\"\"",
			"\tdist = [float(\"inf\")]*N # dist[i]: startからiまでのコスト",
			"\tdist[start] = 0 # スタートは0",
			"\tseen = [False]*N",
			"\t",
			"\thq = [] # コスト, 向かう点",
			"\theapq.heappush(hq, (0, start))",
			"",
			"\twhile hq:",
			"\t\t_, current = heapq.heappop(hq)",
			"\t\t",
			"\t\tif seen[current]: # 同じ点を二度見ない",
			"\t\t\tcontinue",
			"\t\tseen[current] = True",
			"\t\tfor to, cost in edges[current]:",
			"\t\t\tif dist[current] + cost < dist[to]: # 最短距離を更新できるときだけheappush()",
			"\t\t\t\tdist[to] = dist[current] + cost",
			"\t\t\t\theapq.heappush(hq, (dist[current] + cost, to))",
			"\treturn dist",
		]
	},
	"memo_recursion": {
		"prefix": "memo_recursion",
		"body": [
			"from functools import cache",
			"import sys",
			"",
			"sys.setrecursionlimit",
			"#メモ化再帰",
			"@cache",
			"def f(n):",
			"\t${1:pass}",
		]
	},
	"union_find": {
		"prefix": "union_find",
		"body": [
			"class UnionFind():",
			"\t\"\"\"",
			"\t集合を木と捉え、各要素にその根を持たせる",
			"\tUnion : 2つの木を合併する",
			"\tFind : 要素の根を返す",
			"\t\"\"\"",
			"\t",
			"\tdef __init__(self, n) -> None:",
			"\t\t\"\"\"",
			"\t\tparameter",
			"\t\t\tn : 要素数",
			"\t\t\"\"\"",
			"\t\tself.n = n",
			"\t\tself.parents = [-1]*n",
			"\t\tself.rank = [0]*n",
			"\t\tself.size = [1]*n",
			"\t",
			"\tdef find(self, x):",
			"\t\t\"\"\"",
			"\t\txの根を返す",
			"\t\t\"\"\"",
			"\t\tif self.parents[x]==-1:",
			"\t\t\treturn x",
			"\t\telse:",
			"\t\t\t# 値を更新しながら根を探す",
			"\t\t\t# 深さは最大でlog(n)なので、再帰関数でok",
			"\t\t\tself.parents[x] = self.find(self.parents[x])",
			"\t\t\treturn self.parents[x]",
			"\t",
			"\tdef union(self, x, y):",
			"\t\t\"\"\"",
			"\t\txを含む木とyを含む木を合併する",
			"\t\t\"\"\"",
			"\t\tx = self.find(x)",
			"\t\ty = self.find(y)",
			"\t\tnsize = self.size[x]+self.size[y]",
			"\t",
			"\t\tif x==y:",
			"\t\t\treturn",
			"\t\t",
			"\t\tif self.rank[x] > self.rank[y]:",
			"\t\t\tx, y = y, x",
			"\t\t",
			"\t\tself.parents[x] = y",
			"\t\t",
			"\t\tif self.rank[x] == self.rank[y]:",
			"\t\t\tself.rank[y] += 1",
			"\t\t",
			"\t\tself.size[x] = nsize",
			"\t\tself.size[y] = nsize",
		]
	},
	"osa_k": {
		"prefix": "osa_k",
		"body": [
			"# osa_k法",
			"MAXN = ${1:10**6+10}",
			"sieve = [i for i in range(MAXN)] # sieve[i]: iの最も小さい素因数",
			"p = 2",
			"while p*p<=MAXN: # O(MAXN * loglog MAXN)",
			"\tif sieve[p]==p:",
			"\t\tfor q in range(p*p, MAXN, p):",
			"\t\t\tif sieve[q]==q:",
			"\t\t\t\tsieve[q] = p",
			"\tp += 1",
			"",
			"from collections import defaultdict",
			"def prime_factors(n):",
			"\t\"\"\"n(2<=n<=MAXN)の素因数を返す\"\"\"",
			"\td = defaultdict(int) # 適宜変更",
			"\twhile n>1: # O(log n)",
			"\t\td[sieve[n]] += 1",
			"\t\tn //= sieve[n]",
			"\treturn d"
		]
	},
	"doubling": {
		"prefix": "doubling",
		"body": [
			"# ダブリング",
			"import math",
			"",
			"MAX_OP = ${1:K} # 操作の最大回数",
			"P_NUM = ${2:N} # 頂点の個数",
			"DB_NUM = int(math.log2(MAX_OP)) + 1",
			"",
			"# dp[i][j]: 頂点jから2^i回の操作後の頂点",
			"dp = [[0]*P_NUM for _ in range(DB_NUM)]",
			"",
			"# dp[0][0:X]を初期化",
			"for i in range(P_NUM):",
			"\tdp[0][i] = A[i]",
			"",
			"# ダブリングで表を構築 O(P_NUM*logMAX_OP)",
			"for k in range(1, DB_NUM):",
			"\tfor n in range(P_NUM):",
			"\t\tdp[k][n] = dp[k - 1][dp[k - 1][n]]",
			"",
			"",
			"# K回操作後の頂点を得る",
			"now = ${3:0} # 始点",
			"for i in range(DB_NUM):",
			"\tif ${4:K}>>i & 1:",
			"\t\tnow = dp[i][now]"
		]
	},
	"bit_exploretion": {
		"prefix": "bit_exploretion",
		"body": [
			"# bit全探索",
			"A = []",
			"N = len(A)",
			"for i in range(2 ** N):",
			"\tfor j in range(N):",
			"\t\tif not ((i >> j) & 1):",
			"\t\t\tcontinue",
			"\t\t# A[j]を選ぶ場合なので、適当な処理を書く"
		]
	},
	"tree": {
		"prefix": "tree",
		"body":[
			"class Tree:",
			"\t\"\"\"木構造のあれこれをするクラス",
			"\t",
			"\tAttributes",
			"\t----------",
			"\tN: 超点数",
			"\tE[i]: (i番目の辺の始点, 終点)",
			"\tparent[i]: 頂点iの親",
			"\tchilds[i]: 頂点iの直接の子のリスト",
			"\tdepth[i]: 頂点iの深さ",
			"\thierarchy[k]: 深さkの頂点のリスト",
			"\tedges[i]: 頂点iから出る辺の行先のリスト",
			"\tleafs: 葉のリスト",
			"\t\"\"\"",
			"\t",
			"\tdef __init__(self, n, e, root, is_directed=True) -> None:",
			"\t\t\"\"\"",
			"\t\tParameters",
			"\t\t----------",
			"\t\tn : int",
			"\t\t\t頂点の個数",
			"\t\troot : int",
			"\t\t\t根",
			"\t\te: list of int",
			"\t\t\t各辺の(始点, 終点)のlist",
			"\t\t\"\"\"",
			"\t\tself.N = n",
			"\t\tself.E = e",
			"\t\tself.root = root",
			"\t\tself.edges = [[] for _ in range(n)]",
			"\t\tself.is_directed = is_directed",
			"\t\t",
			"\t\tself.set_edges()",
			"\t\tself.set_info()",
			"\t",
			"\tdef set_edges(self):",
			"\t\tfor from_, to in self.E:",
			"\t\t\tself.edges[from_].append(to)",
			"",
			"\t\tif not self.is_directed:",
			"\t\t\tfor to, from_ in self.E:",
			"\t\t\t\tself.edges[from_].append(to)",
			"\t",
			"\tdef set_info(self):",
			"\t\t\"\"\"深さごとの頂点のリスト、親のリスト、子のリストを作る\"\"\"",
			"\t\tself.parent = [None]*self.N",
			"\t\tself.childs = [[] for _ in range(self.N)]",
			"\t\tself.hierarchy = []",
			"\t\tself.depth = [-1]*self.N",
			"\t\tself.leafs = []",
			"\t\t",
			"\t\ttodo = [self.root]",
			"\t\t",
			"\t\t# 初期化",
			"\t\tself.depth[todo[0]] = 0",
			"\t\tself.parent[0] = self.root",
			"\t\tself.hierarchy.append([self.root])",
			"\t\twhile todo:",
			"\t\t\tv = todo.pop()",
			"\t\t\twdepth = self.depth[v]+1",
			"\t\t\tif wdepth>=len(self.hierarchy):",
			"\t\t\t\tself.hierarchy.append([])",
			"\t\t\tfor w in self.edges[v]:",
			"\t\t\t\tif self.depth[w]!=-1:",
			"\t\t\t\t\tcontinue                ",
			"\t\t\t\tself.depth[w] = wdepth",
			"\t\t\t\tself.parent[w] = v",
			"\t\t\t\tself.hierarchy[wdepth].append(w)",
			"\t\t\t\tself.childs[v].append(w)",
			"\t\t\t\t",
			"\t\t\t\ttodo.append(w)",
			"\t\t\t",
			"\t\t\tif not self.childs[v]:",
			"\t\t\t\tself.leafs.append(v)",
			"\t\t\tif not self.hierarchy[-1]:",
			"\t\t\t\tself.hierarchy.pop()"
		]
	},
	"sorted_set": {
		"prefix": "sorted_set",
		"body": [
			"# https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py",
			"import math",
			"from bisect import bisect_left, bisect_right",
			"from typing import Generic, Iterable, Iterator, List, Tuple, TypeVar, Optional",
			"T = TypeVar('T')",
			"",
			"class SortedSet(Generic[T]):",
			"\tBUCKET_RATIO = 16",
			"\tSPLIT_RATIO = 24",
			"\t",
			"\tdef __init__(self, a: Iterable[T] = []) -> None:",
			"\t\t\"\"\"Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)\"\"\"",
			"\t\ta = list(a)",
			"\t\tn = len(a)",
			"\t\tif any(a[i] > a[i + 1] for i in range(n - 1)):",
			"\t\t\ta.sort()",
			"\t\tif any(a[i] >= a[i + 1] for i in range(n - 1)):",
			"\t\t\ta, b = [], a",
			"\t\t\tfor x in b:",
			"\t\t\t\tif not a or a[-1] != x:",
			"\t\t\t\t\ta.append(x)",
			"\t\tn = self.size = len(a)",
			"\t\tnum_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
			"\t\tself.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]",
			"",
			"\tdef __iter__(self) -> Iterator[T]:",
			"\t\tfor i in self.a:",
			"\t\t\tfor j in i: yield j",
			"",
			"\tdef __reversed__(self) -> Iterator[T]:",
			"\t\tfor i in reversed(self.a):",
			"\t\t\tfor j in reversed(i): yield j",
			"\t",
			"\tdef __eq__(self, other) -> bool:",
			"\t\treturn list(self) == list(other)",
			"\t",
			"\tdef __len__(self) -> int:",
			"\t\treturn self.size",
			"\t",
			"\tdef __repr__(self) -> str:",
			"\t\treturn \"SortedSet\" + str(self.a)",
			"\t",
			"\tdef __str__(self) -> str:",
			"\t\ts = str(list(self))",
			"\t\treturn \"{\" + s[1 : len(s) - 1] + \"}\"",
			"",
			"\tdef _position(self, x: T) -> Tuple[List[T], int, int]:",
			"\t\t\"\"\"return the bucket, index of the bucket and position in which x should be. self must not be empty.\"\"\"",
			"\t\tfor i, a in enumerate(self.a):",
			"\t\t\tif x <= a[-1]: break",
			"\t\treturn (a, i, bisect_left(a, x))",
			"",
			"\tdef __contains__(self, x: T) -> bool:",
			"\t\tif self.size == 0: return False",
			"\t\ta, _, i = self._position(x)",
			"\t\treturn i != len(a) and a[i] == x",
			"",
			"\tdef add(self, x: T) -> bool:",
			"\t\t\"\"\"Add an element and return True if added. / O(√N)\"\"\"",
			"\t\tif self.size == 0:",
			"\t\t\tself.a = [[x]]",
			"\t\t\tself.size = 1",
			"\t\t\treturn True",
			"\t\ta, b, i = self._position(x)",
			"\t\tif i != len(a) and a[i] == x: return False",
			"\t\ta.insert(i, x)",
			"\t\tself.size += 1",
			"\t\tif len(a) > len(self.a) * self.SPLIT_RATIO:",
			"\t\t\tmid = len(a) >> 1",
			"\t\t\tself.a[b:b+1] = [a[:mid], a[mid:]]",
			"\t\treturn True",
			"\t",
			"\tdef _pop(self, a: List[T], b: int, i: int) -> T:",
			"\t\tans = a.pop(i)",
			"\t\tself.size -= 1",
			"\t\tif not a: del self.a[b]",
			"\t\treturn ans",
			"",
			"\tdef discard(self, x: T) -> bool:",
			"\t\t\"\"\"Remove an element and return True if removed. / O(√N)\"\"\"",
			"\t\tif self.size == 0: return False",
			"\t\ta, b, i = self._position(x)",
			"\t\tif i == len(a) or a[i] != x: return False",
			"\t\tself._pop(a, b, i)",
			"\t\treturn True",
			"\t",
			"\tdef lt(self, x: T) -> Optional[T]:",
			"\t\t\"\"\"Find the largest element < x, or None if it doesn't exist.\"\"\"",
			"\t\tfor a in reversed(self.a):",
			"\t\t\tif a[0] < x:",
			"\t\t\t\treturn a[bisect_left(a, x) - 1]",
			"",
			"\tdef le(self, x: T) -> Optional[T]:",
			"\t\t\"\"\"Find the largest element <= x, or None if it doesn't exist.\"\"\"",
			"\t\tfor a in reversed(self.a):",
			"\t\t\tif a[0] <= x:",
			"\t\t\t\treturn a[bisect_right(a, x) - 1]",
			"",
			"\tdef gt(self, x: T) -> Optional[T]:",
			"\t\t\"\"\"Find the smallest element > x, or None if it doesn't exist.\"\"\"",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] > x:",
			"\t\t\t\treturn a[bisect_right(a, x)]",
			"",
			"\tdef ge(self, x: T) -> Optional[T]:",
			"\t\t\"\"\"Find the smallest element >= x, or None if it doesn't exist.\"\"\"",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] >= x:",
			"\t\t\t\treturn a[bisect_left(a, x)]",
			"\t",
			"\tdef __getitem__(self, i: int) -> T:",
			"\t\t\"\"\"Return the i-th element.\"\"\"",
			"\t\tif i < 0:",
			"\t\t\tfor a in reversed(self.a):",
			"\t\t\t\ti += len(a)",
			"\t\t\t\tif i >= 0: return a[i]",
			"\t\telse:",
			"\t\t\tfor a in self.a:",
			"\t\t\t\tif i < len(a): return a[i]",
			"\t\t\t\ti -= len(a)",
			"\t\traise IndexError",
			"\t",
			"\tdef pop(self, i: int = -1) -> T:",
			"\t\t\"\"\"Pop and return the i-th element.\"\"\"",
			"\t\tif i < 0:",
			"\t\t\tfor b, a in enumerate(reversed(self.a)):",
			"\t\t\t\ti += len(a)",
			"\t\t\t\tif i >= 0: return self._pop(a, ~b, i)",
			"\t\telse:",
			"\t\t\tfor b, a in enumerate(self.a):",
			"\t\t\t\tif i < len(a): return self._pop(a, b, i)",
			"\t\t\t\ti -= len(a)",
			"\t\traise IndexError",
			"\t",
			"\tdef index(self, x: T) -> int:",
			"\t\t\"\"\"Count the number of elements < x.\"\"\"",
			"\t\tans = 0",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] >= x:",
			"\t\t\t\treturn ans + bisect_left(a, x)",
			"\t\t\tans += len(a)",
			"\t\treturn ans",
			"",
			"\tdef index_right(self, x: T) -> int:",
			"\t\t\"\"\"Count the number of elements <= x.\"\"\"",
			"\t\tans = 0",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] > x:",
			"\t\t\t\treturn ans + bisect_right(a, x)",
			"\t\t\tans += len(a)",
			"\t\treturn ans"
		]
	},
	"sorted_multi_set": {
		"prefix": "sorted_multi_set",
		"body": [
			"# https://github.com/tatyam-prime/SortedSet/blob/main/SortedMultiset.py",
			"import math",
			"from bisect import bisect_left, bisect_right",
			"from typing import Generic, Iterable, Iterator, List, Tuple, TypeVar, Optional",
			"T = TypeVar('T')",
			"",
			"class SortedMultiset(Generic[T]):",
			"\tBUCKET_RATIO = 16",
			"\tSPLIT_RATIO = 24",
			"\t",
			"\tdef __init__(self, a: Iterable[T] = []) -> None:",
			"\t\t\"\"\"Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)\"\"\"",
			"\t\ta = list(a)",
			"\t\tn = self.size = len(a)",
			"\t\tif any(a[i] > a[i + 1] for i in range(n - 1)):",
			"\t\t\ta.sort()",
			"\t\tnum_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
			"\t\tself.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]",
			"",
			"\tdef __iter__(self) -> Iterator[T]:",
			"\t\tfor i in self.a:",
			"\t\t\tfor j in i: yield j",
			"",
			"\tdef __reversed__(self) -> Iterator[T]:",
			"\t\tfor i in reversed(self.a):",
			"\t\t\tfor j in reversed(i): yield j",
			"\t",
			"\tdef __eq__(self, other) -> bool:",
			"\t\treturn list(self) == list(other)",
			"\t",
			"\tdef __len__(self) -> int:",
			"\t\treturn self.size",
			"\t",
			"\tdef __repr__(self) -> str:",
			"\t\treturn \"SortedMultiset\" + str(self.a)",
			"\t",
			"\tdef __str__(self) -> str:",
			"\t\ts = str(list(self))",
			"\t\treturn \"{\" + s[1 : len(s) - 1] + \"}\"",
			"",
			"\tdef _position(self, x: T) -> Tuple[List[T], int, int]:",
			"\t\t\"\"\"return the bucket, index of the bucket and position in which x should be. self must not be empty.\"\"\"",
			"\t\tfor i, a in enumerate(self.a):",
			"\t\t\tif x <= a[-1]: break",
			"\t\treturn (a, i, bisect_left(a, x))",
			"",
			"\tdef __contains__(self, x: T) -> bool:",
			"\t\tif self.size == 0: return False",
			"\t\ta, _, i = self._position(x)",
			"\t\treturn i != len(a) and a[i] == x",
			"",
			"\tdef count(self, x: T) -> int:",
			"\t\t\"\"\"Count the number of x.\"\"\"",
			"\t\treturn self.index_right(x) - self.index(x)",
			"",
			"\tdef add(self, x: T) -> None:",
			"\t\t\"\"\"Add an element. / O(√N)\"\"\"",
			"\t\tif self.size == 0:",
			"\t\t\tself.a = [[x]]",
			"\t\t\tself.size = 1",
			"\t\t\treturn",
			"\t\ta, b, i = self._position(x)",
			"\t\ta.insert(i, x)",
			"\t\tself.size += 1",
			"\t\tif len(a) > len(self.a) * self.SPLIT_RATIO:",
			"\t\t\tmid = len(a) >> 1",
			"\t\t\tself.a[b:b+1] = [a[:mid], a[mid:]]",
			"\t",
			"\tdef _pop(self, a: List[T], b: int, i: int) -> T:",
			"\t\tans = a.pop(i)",
			"\t\tself.size -= 1",
			"\t\tif not a: del self.a[b]",
			"\t\treturn ans",
			"",
			"\tdef discard(self, x: T) -> bool:",
			"\t\t\"\"\"Remove an element and return True if removed. / O(√N)\"\"\"",
			"\t\tif self.size == 0: return False",
			"\t\ta, b, i = self._position(x)",
			"\t\tif i == len(a) or a[i] != x: return False",
			"\t\tself._pop(a, b, i)",
			"\t\treturn True",
			"",
			"\tdef lt(self, x: T) -> Optional[T]:",
			"\t\t\"\"\"Find the largest element < x, or None if it doesn't exist.\"\"\"",
			"\t\tfor a in reversed(self.a):",
			"\t\t\tif a[0] < x:",
			"\t\t\t\treturn a[bisect_left(a, x) - 1]",
			"",
			"\tdef le(self, x: T) -> Optional[T]:",
			"\t\t\"\"\"Find the largest element <= x, or None if it doesn't exist.\"\"\"",
			"\t\tfor a in reversed(self.a):",
			"\t\t\tif a[0] <= x:",
			"\t\t\t\treturn a[bisect_right(a, x) - 1]",
			"",
			"\tdef gt(self, x: T) -> Optional[T]:",
			"\t\t\"\"\"Find the smallest element > x, or None if it doesn't exist.\"\"\"",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] > x:",
			"\t\t\t\treturn a[bisect_right(a, x)]",
			"",
			"\tdef ge(self, x: T) -> Optional[T]:",
			"\t\t\"\"\"Find the smallest element >= x, or None if it doesn't exist.\"\"\"",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] >= x:",
			"\t\t\t\treturn a[bisect_left(a, x)]",
			"\t",
			"\tdef __getitem__(self, i: int) -> T:",
			"\t\t\"\"\"Return the i-th element.\"\"\"",
			"\t\tif i < 0:",
			"\t\t\tfor a in reversed(self.a):",
			"\t\t\t\ti += len(a)",
			"\t\t\t\tif i >= 0: return a[i]",
			"\t\telse:",
			"\t\t\tfor a in self.a:",
			"\t\t\t\tif i < len(a): return a[i]",
			"\t\t\t\ti -= len(a)",
			"\t\traise IndexError",
			"\t",
			"\tdef pop(self, i: int = -1) -> T:",
			"\t\t\"\"\"Pop and return the i-th element.\"\"\"",
			"\t\tif i < 0:",
			"\t\t\tfor b, a in enumerate(reversed(self.a)):",
			"\t\t\t\ti += len(a)",
			"\t\t\t\tif i >= 0: return self._pop(a, ~b, i)",
			"\t\telse:",
			"\t\t\tfor b, a in enumerate(self.a):",
			"\t\t\t\tif i < len(a): return self._pop(a, b, i)",
			"\t\t\t\ti -= len(a)",
			"\t\traise IndexError",
			"",
			"\tdef index(self, x: T) -> int:",
			"\t\t\"\"\"Count the number of elements < x.\"\"\"",
			"\t\tans = 0",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] >= x:",
			"\t\t\t\treturn ans + bisect_left(a, x)",
			"\t\t\tans += len(a)",
			"\t\treturn ans",
			"",
			"\tdef index_right(self, x: T) -> int:",
			"\t\t\"\"\"Count the number of elements <= x.\"\"\"",
			"\t\tans = 0",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] > x:",
			"\t\t\t\treturn ans + bisect_right(a, x)",
			"\t\t\tans += len(a)",
			"\t\treturn ans"
		]
	},
	"mod_int":{
		"prefix": "mod_int",
		"body": [
			"class ModInt:",
				"\tMOD = ...",
				"\tdef __init__(self, value: int) -> None:",
				"\t\tself.value: int = value%ModInt.MOD",
				"\t",
				"\tdef __add__(self, other) -> \"ModInt\":",
				"\t\treturn (ModInt(self.value + other.value)",
				"\t\t\t\tif isinstance(other, ModInt) else",
				"\t\t\t\tModInt(self.value + int(other)))",
				"\t",
				"\tdef __sub__(self, other) -> \"ModInt\":",
				"\t\treturn (ModInt(self.value - other.value)",
				"\t\t\t\tif isinstance(other, ModInt) else",
				"\t\t\t\tModInt(self.value - int(other)))",
				"\t",
				"\tdef __mul__(self, other) -> \"ModInt\":",
				"\t\treturn (ModInt(self.value * other.value)",
				"\t\t\t\tif isinstance(other, ModInt) else",
				"\t\t\t\tModInt(self.value * int(other)))",
				"\t",
				"\tdef __floordiv__(self, other) -> \"ModInt\":",
				"\t\treturn (ModInt(self.value * pow(other.value, -1, ModInt.MOD))",
				"\t\t\t\tif isinstance(other, ModInt) else",
				"\t\t\t\tModInt(self.value * pow(int(other), -1, ModInt.MOD)))",
				"\t\t\t\t",
				"\tdef __pow__(self, other) -> \"ModInt\":",
				"\t\treturn (ModInt(pow(self.value, other.value, ModInt.MOD))",
				"\t\t\t\tif isinstance(other, ModInt) else",
				"\t\t\t\tModInt(pow(self.value, int(other), ModInt.MOD)))",
				"\t",
				"\tdef __eq__(self, value: object) -> bool:",
				"\t\treturn (self.value == value.value and self.MOD == value.MOD",
				"\t\t\t\tif isinstance(value, ModInt) else",
				"\t\t\t\tself.value == int(value))",
				"\t\t",
				"\tdef __radd__(self, other) -> \"ModInt\":",
				"\t\treturn (ModInt(self.value + other.value)",
				"\t\t\t\tif isinstance(other, ModInt) else",
				"\t\t\t\tModInt(self.value + int(other)))",
				"\t",
				"\tdef __rsub__(self, other) -> \"ModInt\":",
				"\t\treturn (ModInt(other.value - self.value)",
				"\t\t\t\tif isinstance(other, ModInt) else",
				"\t\t\t\tModInt(int(other) - self.value))",
				"\t",
				"\tdef __rmul__(self, other) -> \"ModInt\":",
				"\t\treturn (ModInt(self.value * other.value)",
				"\t\t\t\tif isinstance(other, ModInt) else",
				"\t\t\t\tModInt(self.value * int(other)))",
				"\t",
				"\tdef __rfloordiv__(self, other) -> \"ModInt\":",
				"\t\treturn (ModInt(other.value * pow(self.value, -1, ModInt.MOD))",
				"\t\t\t\tif isinstance(other, ModInt) else",
				"\t\t\t\tModInt(int(other) * pow(self.value, -1, ModInt.MOD)))",
				"\t\t\t\t",
				"\tdef __rpow__(self, other) -> \"ModInt\":",
				"\t\treturn (ModInt(pow(other.value, self.value, ModInt.MOD))",
				"\t\t\t\tif isinstance(other, ModInt) else",
				"\t\t\t\tModInt(pow(int(other), self.value, ModInt.MOD)))",
				"\t\t",
				"\tdef __str__(self) -> str:",
				"\t\treturn str(self.value)"
		]
	},
	"MOD": {
		"prefix": "MOD",
		"body": "MOD = 998244353"
	}
}
{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	"main": {
		"prefix": "main",
		"body": [
			"if __name__ == '__main__':",
			"\t${1:pass}"
		],
		"description": "main"
	},
	"direction": {
		"prefix": "direction",
		"body": [
			"s = ${1:str}",
            "if s==\"L\":",
            "\tdelta = (0, -1)",
            "elif s==\"R\":",
            "\tdelta = (0, 1)",
            "elif s==\"U\":",
            "\tdelta = (-1, 0)",
            "elif s==\"D\":",
            "\tdelta = (1, 0)"
		]
	},
	"lrud": {
		"prefix": "lrud",
		"body": "[[0, -1],[0, 1],[-1, 0],[1, 0]]"
	},
	"abcdefg": {
		"prefix": "abcdefg",
		"body": [
			"\"abcdefghijklmnopqrstuvwxyz\""
		]
	},
	"ABCDEFG": {
		"prefix": "ABCDEFG",
		"body": [
			"\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\""
		]
	},
	"N": {
		"prefix": "N",
		"body": [
			"N = int(input())"
		]
	},
	"NM": {
		"prefix": "NM",
		"body": [
			"N, M = map(int, input().split())"
		]
	},
	"HW": {
		"prefix": "HW",
		"body": [
			"H, W = map(int, input().split())"
		]
	},
	"inti": {
		"prefix": "inti",
		"body": [
			"int(input())"
		]
	},
	"mapi": {
		"prefix": "mapi",
		"body": [
			"map(${1:int}, ${2:input().split()})"
		]
	},
	"for_": {
		"prefix": "for_",
		"body": [
			"for _ in range(${1:N}):"
		]
	},
	"fori": {
		"prefix": "fori",
		"body": [
			"for i in range(${1:N}):"
		]
	},
	"forj": {
		"prefix": "forj",
		"body": [
			"for j in range(${1:N}):"
		]
	},
	"sep": {
		"prefix": "sepn",
		"body": "sep=\"\\n\""
	},
	"defaultdict": {
		"prefix": "defaultdict",
		"body": [
			"from collections import defaultdict",
			"d = defaultdict(${1:list})"
		]
	},
	"bisect": {
		"prefix": "bisect",
		"body": [
			"import bisect",
		]
	},
	"heapq": {
		"prefix": "heapq",
		"body": [
			"from heapq import heapify, heappop, heappush",
		]
	},
	"permutation": {
		"prefix": "permutation",
		"body": [
			"# 順列 O(nPk)<=n!",
			"import itertools",
			"for l in itertools.permutations(${1:要素のリスト}, ${2:選ぶ個数}):"
		]
	},
	"combination": {
		"prefix": "combination",
		"body": [
			"# 重複なし組み合わせ O(nCk)",
			"import itertools",
			"for l in itertools.combinations(${1:要素のリスト}, ${2:選ぶ個数}):"
		]
	},
	"homogeneous": {
		"prefix": "homogeneous",
		"body": [
			"# 重複あり組み合わせ O(nHk)=O(n+k-1Ck)",
			"import itertools",
			"for l in itertools.combinations_with_replacement(${1:要素のリスト}, ${2:選ぶ個数}):"
		]
	},
	"syakutori": {
		"prefix": "syakutori",
		"body": [
			"# 尺取り法",
			"ans = 0",
			"right = 0",
			"temp = ${1:初期値} #部分列による値（条件の判定に必要なときに使う）",
			"for left in range(${2:N}):",
			"\twhile ${3:部分列が満たすべき条件}:",
			"\t\ttemp += ${4:A[right]}",
			"\t\tright += 1",
			"\tans = ${5:max}(ans, right-left)",
			"\tif left == right: # [left, right)が空集合なので'temp=初期値'になっているはず",
			"\t\tright += 1",
			"\telse: #このあとleftを+1するので、その分の情報を削る",
			"\t\ttemp -= ${6:A[left]}"
		]
	},
	"BFS": {
		"prefix": "BFS",
		"body": [
			"# BFS",
			"from collections import deque",
			"todo = deque([${1:初期値}])",
			"dist = [-1]*${2:N}",
			"dist[${3:todo[0]}] = 0",
			"while todo:",
			"\tv = todo.popleft()",
			"\tfor ${4:w in d[v]}:",
			"\t\tif dist[w]!=-1: # 既に調べた点は飛ばす",
			"\t\t\tcontinue",
			"\t\ttodo.append(w)",
			"\t\tdist[w] = dist[v]+1"
		]
	},
	"DFS": {
		"prefix": "DFS",
		"body": [
			"# DFS",
			"from collections import deque",
			"todo = deque([${1:初期値}])",
			"seen = [False]*${2:N}",
			"seen[${3:0}] = True",
			"while todo:",
			"\tv = todo.pop()",
			"\tfor ${4:w in d[v]}:",
			"\t\tif seen[${5:w}]:",
			"\t\t\tcontinue",
			"\t\ttodo.append(w)",
			"\t\tseen[w] = True"
		]
	},
	"imos": {
		"prefix": "imos",
		"body": [
			"# imos法",
			"imos = [0]*${1:N}",
			"#始点に+x, 終点の次の点に-xする",
			"# 適当な処理",
			"for i in range(1, len(imos)):",
			"\timos[i] += imos[i-1]"
		]
	},
	"segmentTree": {
		"prefix": "segmentTree",
		"body": [
			"class SegTree:",
			"\tdef __init__(self, num, e, operator=max):",
			"\t\t\"\"\"",
			"\t\tparameter",
			"\t\t\tnum : 要素数",
			"\t\t\te : 単位元(初期値)",
			"\t\t\toperator : 2つの子ノードの値から親ノードの値を作る関数",
			"\t\t\"\"\"",
			"\t\t#self.tree[i+self.offset]:要素iのみの区間の値",
			"\t\tself.offset = 1 << (num-1).bit_length()",
			"\t\tself.tree = [e]*(self.offset<<1)",
			"\t\tself.e = e",
			"\t\tself.operator = operator",
			"\t",
			"\tdef update(self, i, value):",
			"\t\t\"\"\"i番目の要素をvalueにする",
			"\t\t\"\"\"",
			"\t\ti += self.offset",
			"\t\tself.tree[i] = value",
			"\t\t#親ノードを順に変更していく",
			"\t\twhile i>1:",
			"\t\t\tv1, v2 = self.tree[i], self.tree[i^1] #子ノード",
			"\t\t\ti >>= 1 #iを親ノードへずらす",
			"\t\t\tself.tree[i] = self.operator(v1, v2)",
			"\t\t\t",
			"\tdef get_point(self, p):",
			"\t\t\"\"\"p番目の要素を取得する",
			"\t\t\"\"\"",
			"\t\treturn self.tree[p+self.offset]",
			"\t",
			"\tdef get_range(self, l, r):",
			"\t\t\"\"\"区間[l, r)の値を取得する",
			"\t\t\"\"\"",
			"\t\tl += self.offset",
			"\t\tr += self.offset",
			"\t\t",
			"\t\tans = self.e",
			"\t\twhile l<r:",
			"\t\t\tif r&1:",
			"\t\t\t\tans = self.operator(ans, self.tree[r-1])",
			"\t\t\t\tr -= 1",
			"\t\t\tif l&1:",
			"\t\t\t\tans = self.operator(ans, self.tree[l])",
			"\t\t\t\tl += 1",
			"\t\t\tl >>= 1",
			"\t\t\tr >>= 1",
			"\t\treturn ans"
				]
	},
	"dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"import heapq",
			"",
			"def dijkstra(edges, N, start=0):",
			"\t\"\"\"",
			"\tparameter",
			"\t\tedges[i][_] : [点iから向かう点, コスト]",
			"\t\tN : 点の個数(=len(edges))",
			"\t\tstart : 探索を始める点",
			"\t\"\"\"",
			"\tdist = [float(\"inf\")]*N # dist[i]: startからiまでのコスト",
			"\tdist[start] = 0 # スタートは0",
			"\tseen = [False]*N",
			"\t",
			"\thq = [] # コスト, 向かう点",
			"\theapq.heappush(hq, (0, start))",
			"",
			"\twhile hq:",
			"\t\t_, current = heapq.heappop(hq)",
			"\t\t",
			"\t\tif seen[current]: # 同じ点を二度見ない",
			"\t\t\tcontinue",
			"\t\tseen[current] = True",
			"\t\tfor to, cost in edges[current]:",
			"\t\t\tif dist[current] + cost < dist[to]: # 最短距離を更新できるときだけheappush()",
			"\t\t\t\tdist[to] = dist[current] + cost",
			"\t\t\t\theapq.heappush(hq, (dist[current] + cost, to))",
			"\treturn dist",
		]
	},
	"memo_recursion": {
		"prefix": "memo_recursion",
		"body": [
			"from functools import cache",
			"import sys",
			"",
			"sys.setrecursionlimit",
			"#メモ化再帰",
			"@cache",
			"def f(n):",
			"\t${1:pass}",
		]
	},
	"union_find": {
		"prefix": "union_find",
		"body": [
			"class UnionFind():",
			"\t\"\"\"",
			"\t集合を木と捉え、各要素にその根を持たせる",
			"\tUnion : 2つの木を合併する",
			"\tFind : 要素の根を返す",
			"\t\"\"\"",
			"\t",
			"\tdef __init__(self, n) -> None:",
			"\t\t\"\"\"",
			"\t\tparameter",
			"\t\t\tn : 要素数",
			"\t\t\"\"\"",
			"\t\tself.n = n",
			"\t\tself.parents = [-1]*n",
			"\t\tself.rank = [0]*n",
			"\t\tself.size = [1]*n",
			"\t",
			"\tdef find(self, x):",
			"\t\t\"\"\"",
			"\t\txの根を返す",
			"\t\t\"\"\"",
			"\t\tif self.parents[x]==-1:",
			"\t\t\treturn x",
			"\t\telse:",
			"\t\t\t# 値を更新しながら根を探す",
			"\t\t\t# 深さは最大でlog(n)なので、再帰関数でok",
			"\t\t\tself.parents[x] = self.find(self.parents[x])",
			"\t\t\treturn self.parents[x]",
			"\t",
			"\tdef union(self, x, y):",
			"\t\t\"\"\"",
			"\t\txを含む木とyを含む木を合併する",
			"\t\t\"\"\"",
			"\t\tx = self.find(x)",
			"\t\ty = self.find(y)",
			"\t\tnsize = self.size[x]+self.size[y]",
			"\t",
			"\t\tif x==y:",
			"\t\t\treturn",
			"\t\t",
			"\t\tif self.rank[x] > self.rank[y]:",
			"\t\t\tx, y = y, x",
			"\t\t",
			"\t\tself.parents[x] = y",
			"\t\t",
			"\t\tif self.rank[x] == self.rank[y]:",
			"\t\t\tself.rank[y] += 1",
			"\t\t",
			"\t\tself.size[x] = nsize",
			"\t\tself.size[y] = nsize",
		]
	},
	"osa_k": {
		"prefix": "osa_k",
		"body": [
			"# osa_k法",
			"MAXN = ${1:10**6+10}",
			"sieve = [i for i in range(MAXN)] # sieve[i]: iの最も小さい素因数",
			"p = 2",
			"while p*p<=MAXN: # O(MAXN * loglog MAXN)",
			"\tif sieve[p]==p:",
			"\t\tfor q in range(p*p, MAXN, p):",
			"\t\t\tif sieve[q]==q:",
			"\t\t\t\tsieve[q] = p",
			"\tp += 1",
			"",
			"from collections import defaultdict",
			"def prime_factors(n):",
			"\t\"\"\"n(2<=n<=MAXN)の素因数を返す\"\"\"",
			"\td = defaultdict(int) # 適宜変更",
			"\twhile n>1: # O(log n)",
			"\t\td[sieve[n]] += 1",
			"\t\tn //= sieve[n]",
			"\treturn d"
		]
	},
	"doubling": {
		"prefix": "doubling",
		"body": [
			"# ダブリング",
			"import math",
			"",
			"MAX_OP = ${1:K} # 操作の最大回数",
			"P_NUM = ${2:N} # 頂点の個数",
			"DB_NUM = int(math.log2(MAX_OP)) + 1",
			"",
			"# dp[i][j]: 頂点jから2^i回の操作後の頂点",
			"dp = [[0]*P_NUM for _ in range(DB_NUM)]",
			"",
			"# dp[0][0:X]を初期化",
			"for i in range(P_NUM):",
			"\tdp[0][i] = A[i]",
			"",
			"# ダブリングで表を構築 O(P_NUM*logMAX_OP)",
			"for k in range(1, DB_NUM):",
			"\tfor n in range(P_NUM):",
			"\t\tdp[k][n] = dp[k - 1][dp[k - 1][n]]",
			"",
			"",
			"# K回操作後の頂点を得る",
			"now = ${3:0} # 始点",
			"for i in range(DB_NUM):",
			"\tif ${4:K}>>i & 1:",
			"\t\tnow = dp[i][now]"
		]
	},
	"bit_exploretion": {
		"prefix": "bit_exploretion",
		"body": [
			"# bit全探索",
			"A = []",
			"N = len(A)",
			"for i in range(2 ** N):",
			"\tfor j in range(N):",
			"\t\tif not ((i >> j) & 1):",
			"\t\t\tcontinue",
			"\t\t# A[j]を選ぶ場合なので、適当な処理を書く"
		]
	},
	"tree": {
		"prefix": "tree",
		"body":[
			"class Tree:",
			"\t\"\"\"木構造のあれこれをするクラス",
			"\t",
			"\tAttributes",
			"\t----------",
			"\tN: 超点数",
			"\tE[i]: (i番目の辺の始点, 終点)",
			"\tparent[i]: 頂点iの親",
			"\tchilds[i]: 頂点iの直接の子のリスト",
			"\tdepth[i]: 頂点iの深さ",
			"\thierarchy[k]: 深さkの頂点のリスト",
			"\tedges[i]: 頂点iから出る辺の行先のリスト",
			"\tleafs: 葉のリスト",
			"\t\"\"\"",
			"\t",
			"\tdef __init__(self, n, e, root, is_directed=True) -> None:",
			"\t\t\"\"\"",
			"\t\tParameters",
			"\t\t----------",
			"\t\tn : int",
			"\t\t\t頂点の個数",
			"\t\troot : int",
			"\t\t\t根",
			"\t\te: list of int",
			"\t\t\t各辺の(始点, 終点)のlist",
			"\t\t\"\"\"",
			"\t\tself.N = n",
			"\t\tself.E = e",
			"\t\tself.root = root",
			"\t\tself.edges = [[] for _ in range(n)]",
			"\t\tself.is_directed = is_directed",
			"\t\t",
			"\t\tself.set_edges()",
			"\t\tself.set_info()",
			"\t",
			"\tdef set_edges(self):",
			"\t\tfor from_, to in self.E:",
			"\t\t\tself.edges[from_].append(to)",
			"",
			"\t\tif not self.is_directed:",
			"\t\t\tfor to, from_ in self.E:",
			"\t\t\t\tself.edges[from_].append(to)",
			"\t",
			"\tdef set_info(self):",
			"\t\t\"\"\"深さごとの頂点のリスト、親のリスト、子のリストを作る\"\"\"",
			"\t\tself.parent = [None]*self.N",
			"\t\tself.childs = [[] for _ in range(self.N)]",
			"\t\tself.hierarchy = []",
			"\t\tself.depth = [-1]*self.N",
			"\t\tself.leafs = []",
			"\t\t",
			"\t\ttodo = [self.root]",
			"\t\t",
			"\t\t# 初期化",
			"\t\tself.depth[todo[0]] = 0",
			"\t\tself.parent[0] = self.root",
			"\t\tself.hierarchy.append([self.root])",
			"\t\twhile todo:",
			"\t\t\tv = todo.pop()",
			"\t\t\twdepth = self.depth[v]+1",
			"\t\t\tif wdepth>=len(self.hierarchy):",
			"\t\t\t\tself.hierarchy.append([])",
			"\t\t\tfor w in self.edges[v]:",
			"\t\t\t\tif self.depth[w]!=-1:",
			"\t\t\t\t\tcontinue                ",
			"\t\t\t\tself.depth[w] = wdepth",
			"\t\t\t\tself.parent[w] = v",
			"\t\t\t\tself.hierarchy[wdepth].append(w)",
			"\t\t\t\tself.childs[v].append(w)",
			"\t\t\t\t",
			"\t\t\t\ttodo.append(w)",
			"\t\t\t",
			"\t\t\tif not self.childs[v]:",
			"\t\t\t\tself.leafs.append(v)",
			"\t\t\tif not self.hierarchy[-1]:",
			"\t\t\t\tself.hierarchy.pop()"
		]
	},
	"sorted_set": {
		"prefix": "sorted_set",
		"body": [
			"# https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py",
			"import math",
			"from bisect import bisect_left, bisect_right",
			"from typing import Generic, Iterable, Iterator, List, Tuple, TypeVar, Optional",
			"T = TypeVar('T')",
			"",
			"class SortedSet(Generic[T]):",
			"\tBUCKET_RATIO = 16",
			"\tSPLIT_RATIO = 24",
			"\t",
			"\tdef __init__(self, a: Iterable[T] = []) -> None:",
			"\t\t\"\"\"Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)\"\"\"",
			"\t\ta = list(a)",
			"\t\tn = len(a)",
			"\t\tif any(a[i] > a[i + 1] for i in range(n - 1)):",
			"\t\t\ta.sort()",
			"\t\tif any(a[i] >= a[i + 1] for i in range(n - 1)):",
			"\t\t\ta, b = [], a",
			"\t\t\tfor x in b:",
			"\t\t\t\tif not a or a[-1] != x:",
			"\t\t\t\t\ta.append(x)",
			"\t\tn = self.size = len(a)",
			"\t\tnum_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
			"\t\tself.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]",
			"",
			"\tdef __iter__(self) -> Iterator[T]:",
			"\t\tfor i in self.a:",
			"\t\t\tfor j in i: yield j",
			"",
			"\tdef __reversed__(self) -> Iterator[T]:",
			"\t\tfor i in reversed(self.a):",
			"\t\t\tfor j in reversed(i): yield j",
			"\t",
			"\tdef __eq__(self, other) -> bool:",
			"\t\treturn list(self) == list(other)",
			"\t",
			"\tdef __len__(self) -> int:",
			"\t\treturn self.size",
			"\t",
			"\tdef __repr__(self) -> str:",
			"\t\treturn \"SortedSet\" + str(self.a)",
			"\t",
			"\tdef __str__(self) -> str:",
			"\t\ts = str(list(self))",
			"\t\treturn \"{\" + s[1 : len(s) - 1] + \"}\"",
			"",
			"\tdef _position(self, x: T) -> Tuple[List[T], int, int]:",
			"\t\t\"\"\"return the bucket, index of the bucket and position in which x should be. self must not be empty.\"\"\"",
			"\t\tfor i, a in enumerate(self.a):",
			"\t\t\tif x <= a[-1]: break",
			"\t\treturn (a, i, bisect_left(a, x))",
			"",
			"\tdef __contains__(self, x: T) -> bool:",
			"\t\tif self.size == 0: return False",
			"\t\ta, _, i = self._position(x)",
			"\t\treturn i != len(a) and a[i] == x",
			"",
			"\tdef add(self, x: T) -> bool:",
			"\t\t\"\"\"Add an element and return True if added. / O(√N)\"\"\"",
			"\t\tif self.size == 0:",
			"\t\t\tself.a = [[x]]",
			"\t\t\tself.size = 1",
			"\t\t\treturn True",
			"\t\ta, b, i = self._position(x)",
			"\t\tif i != len(a) and a[i] == x: return False",
			"\t\ta.insert(i, x)",
			"\t\tself.size += 1",
			"\t\tif len(a) > len(self.a) * self.SPLIT_RATIO:",
			"\t\t\tmid = len(a) >> 1",
			"\t\t\tself.a[b:b+1] = [a[:mid], a[mid:]]",
			"\t\treturn True",
			"\t",
			"\tdef _pop(self, a: List[T], b: int, i: int) -> T:",
			"\t\tans = a.pop(i)",
			"\t\tself.size -= 1",
			"\t\tif not a: del self.a[b]",
			"\t\treturn ans",
			"",
			"\tdef discard(self, x: T) -> bool:",
			"\t\t\"\"\"Remove an element and return True if removed. / O(√N)\"\"\"",
			"\t\tif self.size == 0: return False",
			"\t\ta, b, i = self._position(x)",
			"\t\tif i == len(a) or a[i] != x: return False",
			"\t\tself._pop(a, b, i)",
			"\t\treturn True",
			"\t",
			"\tdef lt(self, x: T) -> Optional[T]:",
			"\t\t\"\"\"Find the largest element < x, or None if it doesn't exist.\"\"\"",
			"\t\tfor a in reversed(self.a):",
			"\t\t\tif a[0] < x:",
			"\t\t\t\treturn a[bisect_left(a, x) - 1]",
			"",
			"\tdef le(self, x: T) -> Optional[T]:",
			"\t\t\"\"\"Find the largest element <= x, or None if it doesn't exist.\"\"\"",
			"\t\tfor a in reversed(self.a):",
			"\t\t\tif a[0] <= x:",
			"\t\t\t\treturn a[bisect_right(a, x) - 1]",
			"",
			"\tdef gt(self, x: T) -> Optional[T]:",
			"\t\t\"\"\"Find the smallest element > x, or None if it doesn't exist.\"\"\"",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] > x:",
			"\t\t\t\treturn a[bisect_right(a, x)]",
			"",
			"\tdef ge(self, x: T) -> Optional[T]:",
			"\t\t\"\"\"Find the smallest element >= x, or None if it doesn't exist.\"\"\"",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] >= x:",
			"\t\t\t\treturn a[bisect_left(a, x)]",
			"\t",
			"\tdef __getitem__(self, i: int) -> T:",
			"\t\t\"\"\"Return the i-th element.\"\"\"",
			"\t\tif i < 0:",
			"\t\t\tfor a in reversed(self.a):",
			"\t\t\t\ti += len(a)",
			"\t\t\t\tif i >= 0: return a[i]",
			"\t\telse:",
			"\t\t\tfor a in self.a:",
			"\t\t\t\tif i < len(a): return a[i]",
			"\t\t\t\ti -= len(a)",
			"\t\traise IndexError",
			"\t",
			"\tdef pop(self, i: int = -1) -> T:",
			"\t\t\"\"\"Pop and return the i-th element.\"\"\"",
			"\t\tif i < 0:",
			"\t\t\tfor b, a in enumerate(reversed(self.a)):",
			"\t\t\t\ti += len(a)",
			"\t\t\t\tif i >= 0: return self._pop(a, ~b, i)",
			"\t\telse:",
			"\t\t\tfor b, a in enumerate(self.a):",
			"\t\t\t\tif i < len(a): return self._pop(a, b, i)",
			"\t\t\t\ti -= len(a)",
			"\t\traise IndexError",
			"\t",
			"\tdef index(self, x: T) -> int:",
			"\t\t\"\"\"Count the number of elements < x.\"\"\"",
			"\t\tans = 0",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] >= x:",
			"\t\t\t\treturn ans + bisect_left(a, x)",
			"\t\t\tans += len(a)",
			"\t\treturn ans",
			"",
			"\tdef index_right(self, x: T) -> int:",
			"\t\t\"\"\"Count the number of elements <= x.\"\"\"",
			"\t\tans = 0",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] > x:",
			"\t\t\t\treturn ans + bisect_right(a, x)",
			"\t\t\tans += len(a)",
			"\t\treturn ans"
		]
	},
	"sorted_multi_set": {
		"prefix": "sorted_multi_set",
		"body": [
			"# https://github.com/tatyam-prime/SortedSet/blob/main/SortedMultiset.py",
			"import math",
			"from bisect import bisect_left, bisect_right",
			"from typing import Generic, Iterable, Iterator, List, Tuple, TypeVar, Optional",
			"T = TypeVar('T')",
			"",
			"class SortedMultiset(Generic[T]):",
			"\tBUCKET_RATIO = 16",
			"\tSPLIT_RATIO = 24",
			"\t",
			"\tdef __init__(self, a: Iterable[T] = []) -> None:",
			"\t\t\"\"\"Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)\"\"\"",
			"\t\ta = list(a)",
			"\t\tn = self.size = len(a)",
			"\t\tif any(a[i] > a[i + 1] for i in range(n - 1)):",
			"\t\t\ta.sort()",
			"\t\tnum_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
			"\t\tself.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]",
			"",
			"\tdef __iter__(self) -> Iterator[T]:",
			"\t\tfor i in self.a:",
			"\t\t\tfor j in i: yield j",
			"",
			"\tdef __reversed__(self) -> Iterator[T]:",
			"\t\tfor i in reversed(self.a):",
			"\t\t\tfor j in reversed(i): yield j",
			"\t",
			"\tdef __eq__(self, other) -> bool:",
			"\t\treturn list(self) == list(other)",
			"\t",
			"\tdef __len__(self) -> int:",
			"\t\treturn self.size",
			"\t",
			"\tdef __repr__(self) -> str:",
			"\t\treturn \"SortedMultiset\" + str(self.a)",
			"\t",
			"\tdef __str__(self) -> str:",
			"\t\ts = str(list(self))",
			"\t\treturn \"{\" + s[1 : len(s) - 1] + \"}\"",
			"",
			"\tdef _position(self, x: T) -> Tuple[List[T], int, int]:",
			"\t\t\"\"\"return the bucket, index of the bucket and position in which x should be. self must not be empty.\"\"\"",
			"\t\tfor i, a in enumerate(self.a):",
			"\t\t\tif x <= a[-1]: break",
			"\t\treturn (a, i, bisect_left(a, x))",
			"",
			"\tdef __contains__(self, x: T) -> bool:",
			"\t\tif self.size == 0: return False",
			"\t\ta, _, i = self._position(x)",
			"\t\treturn i != len(a) and a[i] == x",
			"",
			"\tdef count(self, x: T) -> int:",
			"\t\t\"\"\"Count the number of x.\"\"\"",
			"\t\treturn self.index_right(x) - self.index(x)",
			"",
			"\tdef add(self, x: T) -> None:",
			"\t\t\"\"\"Add an element. / O(√N)\"\"\"",
			"\t\tif self.size == 0:",
			"\t\t\tself.a = [[x]]",
			"\t\t\tself.size = 1",
			"\t\t\treturn",
			"\t\ta, b, i = self._position(x)",
			"\t\ta.insert(i, x)",
			"\t\tself.size += 1",
			"\t\tif len(a) > len(self.a) * self.SPLIT_RATIO:",
			"\t\t\tmid = len(a) >> 1",
			"\t\t\tself.a[b:b+1] = [a[:mid], a[mid:]]",
			"\t",
			"\tdef _pop(self, a: List[T], b: int, i: int) -> T:",
			"\t\tans = a.pop(i)",
			"\t\tself.size -= 1",
			"\t\tif not a: del self.a[b]",
			"\t\treturn ans",
			"",
			"\tdef discard(self, x: T) -> bool:",
			"\t\t\"\"\"Remove an element and return True if removed. / O(√N)\"\"\"",
			"\t\tif self.size == 0: return False",
			"\t\ta, b, i = self._position(x)",
			"\t\tif i == len(a) or a[i] != x: return False",
			"\t\tself._pop(a, b, i)",
			"\t\treturn True",
			"",
			"\tdef lt(self, x: T) -> Optional[T]:",
			"\t\t\"\"\"Find the largest element < x, or None if it doesn't exist.\"\"\"",
			"\t\tfor a in reversed(self.a):",
			"\t\t\tif a[0] < x:",
			"\t\t\t\treturn a[bisect_left(a, x) - 1]",
			"",
			"\tdef le(self, x: T) -> Optional[T]:",
			"\t\t\"\"\"Find the largest element <= x, or None if it doesn't exist.\"\"\"",
			"\t\tfor a in reversed(self.a):",
			"\t\t\tif a[0] <= x:",
			"\t\t\t\treturn a[bisect_right(a, x) - 1]",
			"",
			"\tdef gt(self, x: T) -> Optional[T]:",
			"\t\t\"\"\"Find the smallest element > x, or None if it doesn't exist.\"\"\"",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] > x:",
			"\t\t\t\treturn a[bisect_right(a, x)]",
			"",
			"\tdef ge(self, x: T) -> Optional[T]:",
			"\t\t\"\"\"Find the smallest element >= x, or None if it doesn't exist.\"\"\"",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] >= x:",
			"\t\t\t\treturn a[bisect_left(a, x)]",
			"\t",
			"\tdef __getitem__(self, i: int) -> T:",
			"\t\t\"\"\"Return the i-th element.\"\"\"",
			"\t\tif i < 0:",
			"\t\t\tfor a in reversed(self.a):",
			"\t\t\t\ti += len(a)",
			"\t\t\t\tif i >= 0: return a[i]",
			"\t\telse:",
			"\t\t\tfor a in self.a:",
			"\t\t\t\tif i < len(a): return a[i]",
			"\t\t\t\ti -= len(a)",
			"\t\traise IndexError",
			"\t",
			"\tdef pop(self, i: int = -1) -> T:",
			"\t\t\"\"\"Pop and return the i-th element.\"\"\"",
			"\t\tif i < 0:",
			"\t\t\tfor b, a in enumerate(reversed(self.a)):",
			"\t\t\t\ti += len(a)",
			"\t\t\t\tif i >= 0: return self._pop(a, ~b, i)",
			"\t\telse:",
			"\t\t\tfor b, a in enumerate(self.a):",
			"\t\t\t\tif i < len(a): return self._pop(a, b, i)",
			"\t\t\t\ti -= len(a)",
			"\t\traise IndexError",
			"",
			"\tdef index(self, x: T) -> int:",
			"\t\t\"\"\"Count the number of elements < x.\"\"\"",
			"\t\tans = 0",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] >= x:",
			"\t\t\t\treturn ans + bisect_left(a, x)",
			"\t\t\tans += len(a)",
			"\t\treturn ans",
			"",
			"\tdef index_right(self, x: T) -> int:",
			"\t\t\"\"\"Count the number of elements <= x.\"\"\"",
			"\t\tans = 0",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] > x:",
			"\t\t\t\treturn ans + bisect_right(a, x)",
			"\t\t\tans += len(a)",
			"\t\treturn ans"
		]
	},
	"MOD": {
		"prefix": "MOD",
		"body": "MOD = 998244353"
	},
	"tree_based_dp": {
		"prefix": "tree_based_dp",
		"body": [
			"from collections import deque",
			"",
			"",
			"def tree_based_dp(size, edges, root=0, e=0, merge=max):",
			"\t\"\"\"木DP",
			"",
			"\tParameters",
			"\t----------",
			"\tsize: 頂点数",
			"\tedges: 隣接リスト",
			"\troot: 根",
			"\te: 単位元",
			"\tmerge: 値をマージする関数",
			"\tvalue_of_leaf: 葉における値を返す関数",
			"",
			"\tExample",
			"\t-------",
			"\tデフォルト引数は、dp[i]: 頂点iを根とする部分木の頂点番号の最大値を返す",
			"",
			"\tUsage",
			"\t-----",
			"\teが初期値でない場合もあるため、適切に変更する",
			"\t\"\"\"",
			"\tdp = [e] * size",
			"",
			"\t# DFS",
			"\ttodo = deque([(root,)])",
			"\tseen = [False] * size",
			"\tseen[root] = True",
			"\twhile todo:",
			"\t\tv, *others = todo.pop()",
			"\t\tif v == -1:",
			"\t\t\tv, w = others",
			"\t\t\tdp[v] = merge(dp[v], dp[w])",
			"\t\t\tcontinue",
			"",
			"\t\tfor w in edges[v]:",
			"\t\t\tif seen[w]:",
			"\t\t\t\tcontinue",
			"\t\t\ttodo.append((-1, v, w))",
			"\t\t\ttodo.append((w,))",
			"\t\t\tseen[w] = True",
			"",
			"\t\tif len(edges[v]) <= 1:  # 葉",
			"\t\t\tdp[v] = v",
			"\treturn dp",
			"",
			"",
		],
    },
    "rerooting_dp": {
        "prefix": "rerooting_dp",
        "body": [
            "from collections import deque",
            "",
            "",
            "def tree_based_dp(size, edges, root=0, e=0, merge=max):",
            "\t\"\"\"木DP",
            "",
            "\tParameters",
            "\t----------",
            "\tsize: 頂点数",
            "\tedges: 隣接リスト",
            "\troot: 根",
            "\te: 単位元",
            "\tmerge: 値をマージする関数",
            "",
            "\tExample",
            "\t-------",
            "\tデフォルト引数は、dp[i]: 頂点iを根とする部分木の頂点番号の最大値を返す",
            "",
            "\tUsage",
            "\t-----",
            "\teが初期値でない場合もあるため、適切に変更する",
            "\t\"\"\"",
            "\tdp = [e] * size",
            "",
            "\t# DFS",
            "\ttodo = deque([(root,)])",
            "\tseen = [False] * size",
            "\tseen[root] = True",
            "\twhile todo:",
            "\t\tv, *others = todo.pop()",
            "\t\tif v == -1:",
            "\t\t\tv, w = others",
            "\t\t\tdp[v] = merge(dp[v], dp[w])",
            "\t\t\tcontinue",
            "",
            "\t\tfor w in edges[v]:",
            "\t\t\tif seen[w]:",
            "\t\t\t\tcontinue",
            "\t\t\ttodo.append((-1, v, w))",
            "\t\t\ttodo.append((w,))",
            "\t\t\tseen[w] = True",
            "",
            "\t\tif len(edges[v]) <= 1:  # 葉",
            "\t\t\tdp[v] = v",
            "\treturn dp",
            "",
            "",
            "def rerooting(size, edges, dp, root=0, e=0, merge=max):",
            "\t\"\"\"",
            "",
            "\tParameters",
            "\t----------",
            "\tsize: 頂点数",
            "\tedges: 隣接リスト",
            "\tdp: rootを根としたときの各部分木の値",
            "\troot: 根",
            "\te: 単位元",
            "\tmerge: 値をマージする関数",
            "",
            "\t\"\"\"",
            "\trerooted_dp = [e] * size",
            "\tinverse_dp = [e] * size",
            "",
            "\t# DFS",
            "\ttodo = deque([(root, None, 0)])  # (頂点, 親, 何番目の子か)",
            "\tcumsum_right = [[] for _ in range(size)]",
            "\tcumsum_left = [[] for _ in range(size)]",
            "\twhile todo:",
            "\t\tv, vp, vi = todo.pop()",
            "\t\t# vにおける各値を計算する",
            "\t\tif vp:",
            "\t\t\t# 問題設定に応じて適切にマージする",
            "\t\t\tinverse_dp[v] = merge(inverse_dp[vp], v)",
            "\t\t\trerooted_dp[v] = merge(",
            "\t\t\t\tinverse_dp[vp],",
            "\t\t\t\tmerge(dp[v], merge(cumsum_right[vp][vi], cumsum_left[vp][vi])),",
            "\t\t\t)",
            "\t\telse:  # 根",
            "\t\t\tinverse_dp[v] = v",
            "\t\t\trerooted_dp[v] = dp[v]",
            "",
            "\t\t# 子の準備",
            "\t\tcumsum_left[v].append(e)",
            "\t\tcumsum_right[v].append(e)",
            "\t\tfor wi, w in enumerate(edges[v]):",
            "\t\t\ttodo.append((w, v, wi))",
            "\t\t\tcumsum_right[v].append(merge(cumsum_right[v][-1], dp[w]))",
            "\t\tfor wi, w in enumerate(reversed(edges[v])):",
            "\t\t\tcumsum_left[v].append(merge(cumsum_left[v][-1], dp[w]))",
            "\t\tcumsum_left[v].reverse()",
            "\treturn rerooted_dp",
            "",
            "",
        ],
        "description": ""
    },

}